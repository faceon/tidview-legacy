import { LitElement, html } from "lit";
import { sharedStyles } from "./sharedStyles";
// tailwind.css is generated by the `build:css` step and imported as raw string
import { adoptTailwind } from "./tailwind-shared.js";
import { parseNumber, formatCurrency } from "../common/format.js";
import cfg from "../common/config.js";
import "@material/web/iconButton/filled-icon-button.js";
import "@material/web/iconButton/icon-button.js";
import "@material/web/icon/icon.js";
import "@material/web/menu/menu.js";
import "@material/web/menu/menu-item.js";
import "./component/positions-list.js";
import "./component/settings-button.js";

class TidviewPortfolio extends LitElement {
  // Static styles intentionally minimal â€” layout and visual styles use Tailwind utilities
  static styles = [sharedStyles];

  static properties = {
    address: { type: String },
    hasAddress: { type: Boolean },
    valuesUpdatedAt: { type: Number },
    valuesError: { type: String },
    statusMessage: { type: String },
    isBusy: { type: Boolean },
    /** @type {any[]} */
    positions: { type: Array },
    positionsLoading: { type: Boolean },
    positionsUpdatedAt: { type: Number },
    positionsValue: { type: Number },
    positionsError: { type: String },
    copied: { type: Boolean },
    cashValue: { type: Number },
    openInPopup: { type: Boolean },
  };

  constructor() {
    super();
    this.address = "";
    this.hasAddress = false;
    this.valuesUpdatedAt = null;
    this.valuesError = "";
    this.statusMessage = "";
    this.isBusy = false;
    this.positions = [];
    this.positionsLoading = false;
    this.positionsUpdatedAt = null;
    this.positionsValue = null;
    this.positionsError = "";
    this.copied = false;
    this.cashValue = null;
    this.openInPopup = false;
    this.lastActiveTabId = null;
    this._refreshTicker = null;
  }

  render() {
    const positionsValue = parseNumber(this.positionsValue);
    const cashValue = parseNumber(this.cashValue);
    const totalValue =
      positionsValue == null && cashValue == null
        ? null
        : (positionsValue ?? 0) + (cashValue ?? 0);

    const displayValues = {
      total: formatCurrency(totalValue),
      positions: formatCurrency(positionsValue),
      cash: formatCurrency(cashValue),
    };

    return html`
      <header
        class="w-full box-border min-w-[320px] overflow-x-hidden overflow-y-auto bg-white text-[#111] leading-[1.4] p-3"
      >
        <!-- top most row for logo and controls -->

        <nav class="flex items-center justify-between gap-3">
          <figure>
            <img src="icons/icon16.png" alt="Tidview Logo" />
          </figure>

          <h3>Tidview</h3>

          <md-icon-button @click=${() => location.reload()}>
            <md-icon>restore_page</md-icon>
          </md-icon-button>

          <md-filled-icon-button
            @click=${this.handleRefresh}
            ?disabled=${this.isBusy || !this.hasAddress}
          >
            <md-icon>sync</md-icon>
          </md-filled-icon-button>

          <span class="w-12 text-right text-xs text-gray-500">
            ${typeof this.valuesUpdatedAt === "number"
              ? this.getRefreshAgeLabel()
              : ""}
          </span>

          <settings-button
            .address=${this.address}
            .openInPopup=${this.openInPopup}
          ></settings-button>
        </nav>

        <!-- address form -->
        <div class="${this.hasAddress ? "hidden" : "flex items-center gap-2"}">
          >
          <label for="address">Your 0x address</label>
          <input
            class="border border-gray-200 rounded px-2 py-1 text-sm"
            id="address"
            type="text"
            placeholder="0x...40 hex chars"
            .value=${this.address}
            @input=${this.handleInput}
            autocomplete="off"
          />

          <button
            class="px-2 py-1 rounded bg-slate-200 text-sm"
            @click=${this.handleSave}
            ?disabled=${this.isBusy}
          >
            Save
          </button>
          <button
            class="px-2 py-1 rounded bg-slate-200 text-sm"
            @click=${this.handleRefresh}
            ?disabled=${this.isBusy}
          >
            Refresh
          </button>
        </div>

        <!-- Total: latest positions value + cash -->
        <div class="flex items-center justify-between gap-3">
          <div
            class="${!this.valuesError
              ? "hidden"
              : "p-3 rounded-md bg-tid-bg-danger text-tid-negative text-xs"}"
          >
            ${this.valuesError}
          </div>

          <div
            class="flex gap-3 border border-gray-200 rounded-md p-3 bg-[#fafafa]"
          >
            <div class="flex flex-col">
              <span class="text-xs text-tid-muted">Total</span>
              <span class="text-base font-semibold text-tid-text"
                >${displayValues.total}</span
              >
            </div>
          </div>

          <div
            class="flex gap-3 border border-gray-200 rounded-md p-3 bg-[#fafafa]"
          >
            <div class="flex flex-col">
              <span class="text-xs text-tid-muted">Positions</span>
              <span class="text-sm font-semibold text-tid-text"
                >${displayValues.positions}</span
              >
            </div>
            <div class="flex flex-col">
              <span class="text-xs text-tid-muted">Cash</span>
              <span class="text-sm font-semibold text-tid-text"
                >${displayValues.cash}</span
              >
            </div>
          </div>
        </div>
      </header>

      <!-- positions -->
      <main>
        <positions-list
          .positions=${/** @type {any} */ (this.positions)}
          .loading=${this.positionsLoading}
          .openMarket=${this.openMarket}
        ></positions-list>
      </main>

      <!-- updated time -->
      <footer class="p-3 flex flex-col gap-1">
        ${this.positionsError
          ? html`<div
              class="p-3 rounded-md bg-tid-bg-danger text-tid-negative text-xs"
            >
              ${this.positionsError}
            </div>`
          : ""}
        ${this.statusMessage
          ? html`<div class="text-xs text-tid-muted">
              ${this.statusMessage}
            </div>`
          : ""}
        ${this.positionsUpdatedAt
          ? html`<div class="text-xs text-tid-muted">
              Positions refreshed:
              ${new Date(this.positionsUpdatedAt).toLocaleString()}
            </div>`
          : ""}
      </footer>
    `;
  }

  connectedCallback() {
    super.connectedCallback();
    // Adopt the shared tailwind stylesheet into this component's shadow root
    adoptTailwind(this.renderRoot);
    if (chrome?.storage?.onChanged) {
      chrome.storage.onChanged.addListener(this.handleStorageChange);
    }
    this.initFromStorage();
    this.startRefreshTicker();
  }

  disconnectedCallback() {
    if (chrome?.storage?.onChanged) {
      chrome.storage.onChanged.removeListener(this.handleStorageChange);
    }
    super.disconnectedCallback();
    this.stopRefreshTicker();
  }

  startRefreshTicker() {
    if (this._refreshTicker != null || typeof window === "undefined") {
      return;
    }
    this._refreshTicker = window.setInterval(() => {
      if (this.valuesUpdatedAt) {
        this.requestUpdate();
      }
    }, 1000);
  }

  stopRefreshTicker() {
    if (this._refreshTicker != null) {
      window.clearInterval(this._refreshTicker);
      this._refreshTicker = null;
    }
  }

  getRefreshAgeLabel() {
    if (typeof this.valuesUpdatedAt !== "number") {
      return "";
    }
    const age = Math.max(Date.now() - this.valuesUpdatedAt, 0);
    if (age < 60 * 1000) {
      const seconds = Math.max(Math.floor(age / 1000), 0);
      return `${seconds}s`;
    }
    if (age < 60 * 60 * 1000) {
      const minutes = Math.floor(age / (60 * 1000));
      return `${minutes}m`;
    }
    const hours = Math.floor(age / (60 * 60 * 1000));
    return `${hours}h`;
  }

  async initFromStorage() {
    try {
      if (!chrome?.storage?.sync || !chrome?.storage?.session) {
        return;
      }

      const [syncData, sessionData] = await Promise.all([
        chrome.storage.sync.get(),
        chrome.storage.session.get(),
      ]);

      const {
        address,
        valuesUpdatedAt,
        valuesError,
        positionsValue,
        cashValue,
        openInPopup,
      } = syncData;

      this.address = typeof address === "string" ? address.trim() : "";
      this.hasAddress = cfg.ADDRESS_REGEX.test(this.address);
      this.valuesUpdatedAt =
        typeof valuesUpdatedAt === "number"
          ? valuesUpdatedAt
          : parseNumber(valuesUpdatedAt);
      this.valuesError = valuesError ?? "";
      this.positionsValue =
        typeof positionsValue === "number"
          ? positionsValue
          : parseNumber(positionsValue);
      this.cashValue =
        typeof cashValue === "number" ? cashValue : parseNumber(cashValue);
      this.openInPopup = Boolean(openInPopup);

      const hasPositionsData = Array.isArray(sessionData?.positions);
      this.positionsLoading = this.hasAddress && !hasPositionsData;

      this.applyPositionsState(
        {
          positions: sessionData?.positions,
          positionsUpdatedAt: sessionData?.positionsUpdatedAt,
          positionsError: sessionData?.positionsError,
        },
        { silent: true },
      );

      this.updateStatusFromState();
    } catch (error) {
      console.error("Failed to initialize from storage", error);
      this.valuesError = "Unable to load current status.";
      this.statusMessage = "";
    }
  }

  handleStorageChange = (changes, areaName) => {
    if (areaName === "sync") {
      let shouldUpdateStatus = false;

      if (Object.prototype.hasOwnProperty.call(changes, "address")) {
        const newAddressRaw = changes.address.newValue;
        const newAddress =
          typeof newAddressRaw === "string" ? newAddressRaw.trim() : "";
        const previousAddress = this.address;
        this.address = newAddress;
        this.hasAddress = cfg.ADDRESS_REGEX.test(newAddress);

        if (this.hasAddress && newAddress !== previousAddress) {
          this.positions = [];
          this.positionsValue = null;
          this.positionsUpdatedAt = null;
          this.positionsError = "";
          this.positionsLoading = true;
        }

        if (!this.hasAddress) {
          this.positions = [];
          this.positionsValue = null;
          this.positionsUpdatedAt = null;
          this.positionsError = "";
          this.positionsLoading = false;
        }
      }

      if (Object.prototype.hasOwnProperty.call(changes, "positionsValue")) {
        this.positionsValue = parseNumber(changes.positionsValue.newValue);
      }

      if (Object.prototype.hasOwnProperty.call(changes, "cashValue")) {
        this.cashValue = parseNumber(changes.cashValue.newValue);
      }

      if (Object.prototype.hasOwnProperty.call(changes, "valuesUpdatedAt")) {
        const rawValue = changes.valuesUpdatedAt.newValue;
        this.valuesUpdatedAt =
          typeof rawValue === "number" ? rawValue : parseNumber(rawValue);
        shouldUpdateStatus = true;
      }

      if (Object.prototype.hasOwnProperty.call(changes, "valuesError")) {
        const errorValue = changes.valuesError.newValue;
        this.valuesError = errorValue ? String(errorValue) : "";
        shouldUpdateStatus = true;
      }

      if (Object.prototype.hasOwnProperty.call(changes, "openInPopup")) {
        this.openInPopup = Boolean(changes.openInPopup.newValue);
      }

      if (shouldUpdateStatus) {
        this.updateStatusFromState();
      }

      return;
    }

    if (areaName === "session") {
      const sessionUpdate = {};

      if (Object.prototype.hasOwnProperty.call(changes, "positions")) {
        sessionUpdate.positions = changes.positions.newValue;
      }

      if (Object.prototype.hasOwnProperty.call(changes, "positionsUpdatedAt")) {
        sessionUpdate.positionsUpdatedAt = changes.positionsUpdatedAt.newValue;
      }

      if (Object.prototype.hasOwnProperty.call(changes, "positionsError")) {
        sessionUpdate.positionsError = changes.positionsError.newValue;
      }

      if (Object.keys(sessionUpdate).length) {
        this.applyPositionsState(sessionUpdate);
      }
    }
  };

  updateStatusFromState() {
    if (this.valuesError) {
      this.statusMessage = "";
      return;
    }

    if (
      typeof this.valuesUpdatedAt === "number" &&
      !Number.isNaN(this.valuesUpdatedAt)
    ) {
      this.statusMessage = `Last updated: ${new Date(this.valuesUpdatedAt).toLocaleString()}`;
    } else {
      this.statusMessage = "";
    }
  }

  handleInput(event) {
    this.address = event.target.value;
  }

  async handleSave() {
    const trimmed = this.address.trim();
    if (!cfg.ADDRESS_REGEX.test(trimmed)) {
      this.lastError = "Please enter a valid 0x address.";
      this.statusMessage = "";
      return;
    }

    this.isBusy = true;
    this.valuesError = "";
    this.statusMessage = "Saved. Refreshing...";
    this.positionsLoading = true;
    this.positionsError = "";
    try {
      await chrome.storage.sync.set({ address: trimmed });
      this.address = trimmed;
      const refreshOk = await this.requestRefresh({ recordTimestamp: true });
      if (refreshOk) {
        this.statusMessage = `Refreshed at ${new Date().toLocaleString()}`;
      }
    } catch (error) {
      console.error("Failed to save address", error);
      this.valuesError = error?.message || "Failed to save address.";
      this.statusMessage = "";
      this.positionsLoading = false;
    } finally {
      this.isBusy = false;
    }
  }

  async handleRefresh() {
    const trimmed = this.address.trim();
    if (!cfg.ADDRESS_REGEX.test(trimmed)) {
      this.valuesError = "Please enter a valid 0x address.";
      this.statusMessage = "";
      return;
    }

    this.isBusy = true;
    this.valuesError = "";
    this.statusMessage = "Refreshing...";
    this.positionsLoading = true;
    this.positionsError = "";
    try {
      this.address = trimmed;
      const refreshOk = await this.requestRefresh({ recordTimestamp: true });
      if (refreshOk) {
        this.statusMessage = `Refreshed at ${new Date().toLocaleString()}`;
      }
    } catch (error) {
      console.error("Failed to refresh balance", error);
      this.valuesError = error?.message || "Failed to refresh balance.";
      this.statusMessage = "";
      this.positionsLoading = false;
    } finally {
      this.isBusy = false;
    }
  }

  async requestRefresh({ recordTimestamp = false } = {}) {
    try {
      const res = await chrome.runtime.sendMessage({ type: "refresh" });
      if (!res?.success) {
        throw new Error(res?.error || "Unknown error during refresh");
      }
      return true;
    } catch (error) {
      const errorMessage = error?.message || "Failed to refresh balance.";
      console.error("Failed to refresh", errorMessage);
      this.valuesError = errorMessage;
      if (!recordTimestamp && this.valuesUpdatedAt) {
        this.statusMessage = `Last updated: ${new Date(this.valuesUpdatedAt).toLocaleString()}`;
      } else {
        this.statusMessage = "";
      }
      return false;
    } finally {
      this.positionsLoading = false;
    }
  }

  applyPositionsState(state, { silent = false } = {}) {
    let touched = false;

    if (Object.prototype.hasOwnProperty.call(state, "positions")) {
      const rawPositions = state.positions;
      if (typeof rawPositions === "undefined") {
        // Positions not yet available
      } else if (Array.isArray(rawPositions)) {
        const normalized = rawPositions.map((entry) =>
          this.normalizePosition(entry),
        );
        normalized.sort(
          (a, b) => (b.currentValue ?? 0) - (a.currentValue ?? 0),
        );
        this.positions = normalized;
        const computedValue = normalized.reduce((sum, pos) => {
          const value = parseNumber(pos?.currentValue);
          return value != null ? sum + value : sum;
        }, 0);
        this.positionsValue = computedValue;
        touched = true;
      } else {
        this.positions = [];
        this.positionsValue = null;
        touched = true;
      }
    }

    if (Object.prototype.hasOwnProperty.call(state, "positionsUpdatedAt")) {
      const rawUpdatedAt = state.positionsUpdatedAt;
      if (typeof rawUpdatedAt !== "undefined") {
        this.positionsUpdatedAt =
          typeof rawUpdatedAt === "number" && !Number.isNaN(rawUpdatedAt)
            ? rawUpdatedAt
            : null;
        touched = true;
      }
    }

    if (Object.prototype.hasOwnProperty.call(state, "positionsError")) {
      const errorValue = state.positionsError;
      if (typeof errorValue !== "undefined") {
        this.positionsError = errorValue ? String(errorValue) : "";
        if (!silent && this.positionsError) {
          this.statusMessage = "";
        }
        touched = true;
      }
    }

    if (touched) {
      this.positionsLoading = false;
    }
  }

  normalizePosition(raw) {
    const id =
      raw?.asset ||
      (raw?.slug && raw?.outcome
        ? `${raw.slug}-${raw.outcome}`
        : raw?.conditionId ||
          raw?.title ||
          `pos-${Date.now()}-${Math.random().toString(16).slice(2)}`);

    return {
      id,
      title: raw?.title || raw?.slug || "Unnamed market",
      outcome: raw?.outcome || "",
      currentValue: parseNumber(raw?.currentValue),
      cashPnl: parseNumber(raw?.cashPnl),
      percentPnl: parseNumber(raw?.percentPnl),
      size: parseNumber(raw?.size),
      avgPrice: parseNumber(raw?.avgPrice),
      curPrice: parseNumber(raw?.curPrice),
      endDate: raw?.endDate || "",
      icon: raw?.icon || "",
      initialValue: parseNumber(raw?.initialValue),
      realizedPnl: parseNumber(raw?.realizedPnl),
      slug: raw?.slug || "",
      eventSlug: raw?.eventSlug || "",
    };
  }

  openMarket = (slug, fallbackSlug) => {
    const finalSlug = slug || fallbackSlug;
    if (!finalSlug) return;
    const url = `https://polymarket.com/market/${finalSlug}`;
    if (typeof chrome !== "undefined" && chrome?.tabs?.create) {
      chrome.tabs.create({ url });
    } else {
      window.open(url, "_blank", "noopener,noreferrer");
    }
  };
}

customElements.define("tidview-portfolio", TidviewPortfolio);
